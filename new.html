<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Ø£Ø­Ø¯Ø« Ø­Ù„Ù‚Ø§Øª</title>
    <link rel="stylesheet" href="/CSS/style.css" />
    <script src="navbar.js" defer></script>
    <link rel="icon" href="https://abdo12249.github.io/1/navbar/favicon.ico" type="image/x-icon" />

    <!-- Firebase SDKs -->
<!-- Firebase SDK v9 (Ù…ØªÙˆØ§ÙÙ‚Ø© Ù…Ø¹ ÙƒÙˆØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ) -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-analytics-compat.js"></script>


    <style>
        /* Pagination styling for the navigation buttons */
        .pagination {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 8px;
            margin: 20px 0;
        }
        .pagination button {
            padding: 6px 12px;
            background-color: var(--primary-color, #ef4444);
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 6px;
            transition: background-color 0.3s ease; /* Smooth transition for hover effects */
        }
        .pagination button:hover {
            background-color: #dc2626; /* Slightly darker on hover */
        }
        .pagination button.active {
            background-color: #b91c1c; /* Active button color */
        }
        .pagination span {
            padding: 6px 12px;
            color: #888;
        }

        /* Loading overlay styles */
        .loading-overlay {
            position: fixed; /* Fixed position to cover the entire viewport */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black background */
            display: flex; /* Use flexbox for centering content */
            flex-direction: column; /* Stack items vertically */
            justify-content: center; /* Center vertically */
            align-items: center; /* Center horizontally */
            z-index: 1000; /* Ensure it's on top of other content */
            color: white; /* Text color */
            font-size: 1.2em; /* Larger font size for text */
        }

        /* Spinner animation */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3); /* Light border for the spinner */
            border-top: 4px solid #fff; /* White top border for animation */
            border-radius: 50%; /* Make it circular */
            width: 40px; /* Spinner width */
            height: 40px; /* Spinner height */
            animation: spin 1s linear infinite; /* Spin animation */
            margin-bottom: 15px; /* Space below the spinner */
        }

        /* Keyframes for the spin animation */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Anime card image loading transition */

        .anime-image img.loaded {
            opacity: 1; /* Fully visible when loaded */
        }
    </style>
</head>
<body>

<div id="navbar-container"></div>

<main>
    <div class="section-header">
        <h1>Ø£Ø­Ø¯Ø« Ø­Ù„Ù‚Ø§Øª</h1>
    </div>

<div style="max-width:100%;overflow:hidden;">
    <script type="text/javascript">
        atOptions = {
            'key' : 'fcb1605c77b3fd33d38ff238d2ffbd00',
            'format' : 'iframe',
            'height' : 90,
            'width' : 728,
            'params' : {}
        };
    </script>
    <script type="text/javascript" src="//www.highperformanceformat.com/fcb1605c77b3fd33d38ff238d2ffbd00/invoke.js"></script>
</div>

<style>
iframe {
    max-width: 100% !important;
    height: auto !important;
}
</style>

    
    <div class="anime-grid" id="animeGrid"></div>
    <div class="pagination" id="pagination"></div>

    <!-- Loading screen overlay -->
    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="spinner"></div>
        <span>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…ÙŠ...</span>
    </div>


<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
import { getFirestore, collection, getDocs, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyCNr3gwtfmqmObVHmTS6K9jvAlcGLZmWAs",
  authDomain: "invertible-pipe-452821-h7.firebaseapp.com",
  projectId: "invertible-pipe-452821-h7",
  storageBucket: "invertible-pipe-452821-h7.firebasestorage.app",
  messagingSenderId: "638279299611",
  appId: "1:638279299611:web:822fb4f02e5943121f3ebe",
  measurementId: "G-9RNN5BS7DG"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const maxItemsPerPage = 20;
const EPISODES_PER_PART = 500;

let partsCache = {};   // ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ù…Ø­Ù…Ù‘Ù„Ø© Ù…Ø¤Ù‚ØªÙ‹Ø§
let totalEpisodes = 0;

// ---------------- Ø£Ø¯ÙˆØ§Øª ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ----------------
function showLoading() { document.getElementById("loadingOverlay").style.display = "flex"; }
function hideLoading() { document.getElementById("loadingOverlay").style.display = "none"; }
function getPageFromURL() { const params = new URLSearchParams(window.location.search); return parseInt(params.get("page")) || 1; }
function updateURL(page) { const url = new URL(window.location.href); url.searchParams.set("page", page); window.history.pushState({}, "", url); }

function setupLazyLoading() {
  const lazyImages = document.querySelectorAll("img[data-src]");
  const observer = new IntersectionObserver((entries, obs) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        img.src = img.dataset.src;
        img.removeAttribute("data-src");
        obs.unobserve(img);
      }
    });
  }, { rootMargin: "100px" });
  lazyImages.forEach(img => observer.observe(img));
}

// ---------------- ØªØ­Ù…ÙŠÙ„ Ø¬Ø²Ø¡ Ù…Ø¹ÙŠÙ† ÙÙ‚Ø· ----------------
async function loadPart(partNumber) {
  if (partsCache[partNumber]) return partsCache[partNumber];

  const partDocRef = doc(db, "episodes", `part${partNumber}`);
  const snapshot = await getDoc(partDocRef);
  if (!snapshot.exists()) return [];
  
  const episodes = snapshot.data().episodes;
  partsCache[partNumber] = episodes;
  return episodes;
}

// ---------------- Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø­Ù„Ù‚Ø§Øª Ø§Ù„ØµÙØ­Ø© ----------------
async function getEpisodesForPage(pageNumber) {
  const startIndex = (pageNumber - 1) * maxItemsPerPage;
  const endIndex = startIndex + maxItemsPerPage - 1;

  const startPart = Math.floor(startIndex / EPISODES_PER_PART) + 1;
  const endPart = Math.floor(endIndex / EPISODES_PER_PART) + 1;

  let episodes = [];
  for (let partNum = startPart; partNum <= endPart; partNum++) {
    const partEpisodes = await loadPart(partNum);
    episodes.push(...partEpisodes);
  }

  const localStart = startIndex - ((startPart - 1) * EPISODES_PER_PART);
  const localEnd = localStart + maxItemsPerPage;
  return episodes.slice(localStart, localEnd);
}

// ---------------- Ø¹Ø±Ø¶ Ø§Ù„ØµÙØ­Ø© ----------------
async function renderPage(pageNumber) {
  updateURL(pageNumber);
  const animeGrid = document.getElementById("animeGrid");
  animeGrid.innerHTML = "";
  
  const episodesToShow = await getEpisodesForPage(pageNumber);
  episodesToShow.forEach(ep => {
    const card = document.createElement("div");
    card.className = "anime-card";
    card.innerHTML = `
      <div class="anime-image">
        <img data-src="${ep.image}" alt="${ep.animeTitle}" loading="lazy">
      </div>
      <div class="anime-info">
        <h3>${ep.animeTitle}</h3>
        <div class="anime-meta">
          <span>${ep.title}</span>
          <a href="${ep.link}" class="watch-button">Ø´Ø§Ù‡Ø¯ Ø§Ù„Ø¢Ù†</a>
        </div>
      </div>`;
    animeGrid.appendChild(card);
  });

  setupLazyLoading();
  setupPagination(totalEpisodes, pageNumber);
  window.scrollTo({ top: 0, behavior: "smooth" });
}

// ---------------- Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØªØ±Ù‚ÙŠÙ… ----------------
function setupPagination(totalItems, currentPage) {
  const pageCount = Math.ceil(totalItems / maxItemsPerPage);
  const pagination = document.getElementById("pagination");
  pagination.innerHTML = "";
  const maxVisible = 5;
  let start = Math.max(1, currentPage - Math.floor(maxVisible / 2));
  let end = Math.min(start + maxVisible - 1, pageCount);
  if (end - start < maxVisible - 1) start = Math.max(1, end - maxVisible + 1);

  if (currentPage > 1) {
    const prev = document.createElement("button");
    prev.textContent = "Ø§Ù„Ø³Ø§Ø¨Ù‚";
    prev.onclick = () => renderPage(currentPage - 1);
    pagination.appendChild(prev);
  }

  for (let i = start; i <= end; i++) {
    const btn = document.createElement("button");
    btn.textContent = i;
    if (i === currentPage) btn.classList.add("active");
    btn.onclick = () => renderPage(i);
    pagination.appendChild(btn);
  }

  if (currentPage < pageCount) {
    const next = document.createElement("button");
    next.textContent = "Ø§Ù„ØªØ§Ù„ÙŠ";
    next.onclick = () => renderPage(currentPage + 1);
    pagination.appendChild(next);
  }
}

// ---------------- Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ù„Ù‚Ø§Øª Ø§Ù„ÙƒÙ„ÙŠ ----------------
async function getTotalEpisodes() {
  const snapshot = await getDocs(collection(db, "episodes"));
  let maxEpisodes = 0;
  snapshot.forEach(docSnap => {
    if (docSnap.id.startsWith("part")) {
      const partNumber = parseInt(docSnap.id.replace("part", ""), 10);
      maxEpisodes = Math.max(maxEpisodes, (partNumber - 1) * EPISODES_PER_PART + docSnap.data().episodes.length);
    }
  });
  return maxEpisodes;
}

// ---------------- Ø±ÙØ¹ Ø£Ø¬Ø²Ø§Ø¡ Ø¬Ø¯ÙŠØ¯Ø© Ø¹Ù†Ø¯ ÙˆØ¬ÙˆØ¯ ØªØºÙŠÙŠØ±Ø§Øª ----------------
async function uploadEpisodesInParts(episodes) {
  episodes.sort((a, b) => new Date(b.date) - new Date(a.date));
  const totalParts = Math.ceil(episodes.length / EPISODES_PER_PART);

  for (let i = 0; i < totalParts; i++) {
    const start = i * EPISODES_PER_PART;
    const end = start + EPISODES_PER_PART;
    const partEpisodes = episodes.slice(start, end);
    const partDocRef = doc(db, "episodes", `part${i+1}`);
    const existing = await getDoc(partDocRef);

    if (existing.exists()) {
      const oldData = existing.data().episodes;
      const changed = JSON.stringify(oldData) !== JSON.stringify(partEpisodes);
      if (!changed) {
        console.log(`â­ï¸ Ø§Ù„Ø¬Ø²Ø¡ part${i+1} Ù„Ù… ÙŠØªØºÙŠØ±.`);
        continue;
      }
    }

    await setDoc(partDocRef, { episodes: partEpisodes, updatedAt: Date.now() });
    console.log(`âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø£Ùˆ Ø¥Ù†Ø´Ø§Ø¡ part${i+1} (${partEpisodes.length} Ø­Ù„Ù‚Ø©)`);
  }
}

// ---------------- Ø¬Ù„Ø¨ Ø­Ù„Ù‚Ø§Øª Ù…Ù† Ù…Ù„Ù Ø¬Ø¯ÙŠØ¯ ----------------
async function fetchNewEpisodes() {
  const res = await fetch("Ø§Ù„Ø¬Ø¯ÙŠØ¯.json");
  const data = await res.json();
  const animeLinks = data.animes;
  const fetched = [];

  // ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø£Ù†Ù…ÙŠ ÙˆØ§Ø­Ø¯ ØªÙ„Ùˆ Ø§Ù„Ø¢Ø®Ø±
  for (const animeData of animeLinks) {
    try {
      const response = await fetch(animeData);
      const anime = await response.json();
      anime.episodes.forEach(ep => {
        fetched.push({
          animeTitle: anime.animeTitle,
          image: ep.image,
          link: ep.link,
          number: ep.number,
          title: ep.title,
          date: ep.date || new Date().toISOString()
        });
      });
    } catch (e) {
      console.error("Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø£Ù†Ù…ÙŠ:", animeData, e);
    }
  }
  return fetched;
}

// ---------------- Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ø£Ùˆ Ø§Ù„ØªØºÙŠÙŠØ± ----------------
async function checkForUpdates() {
  showLoading();
  const existingEpisodes = [];

  const snapshot = await getDocs(collection(db, "episodes"));
  snapshot.forEach(docSnap => {
    if (docSnap.id.startsWith("part")) existingEpisodes.push(...docSnap.data().episodes);
  });

  const newEpisodes = await fetchNewEpisodes();
  const updates = newEpisodes.filter(ep => {
    const old = existingEpisodes.find(o => o.link === ep.link);
    return !old || JSON.stringify(old) !== JSON.stringify(ep);
  });

  if (updates.length > 0) {
    console.log(`âœ¨ ØªÙ… Ø§ÙƒØªØ´Ø§Ù ${updates.length} Ø­Ù„Ù‚Ø© Ø¬Ø¯ÙŠØ¯Ø© Ø£Ùˆ Ù…Ø­Ø¯Ø«Ø©`);
    const merged = [...updates, ...existingEpisodes.filter(o => !updates.some(n => n.link === o.link))];
    merged.sort((a, b) => new Date(b.date) - new Date(a.date));
    await uploadEpisodesInParts(merged);
    partsCache = {}; // Ù…Ø³Ø­ Ø§Ù„ÙƒØ§Ø´ Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©
    totalEpisodes = await getTotalEpisodes();
  } else {
    console.log("âœ… Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø£Ùˆ ØªØºÙŠÙŠØ±Ø§Øª.");
  }

  hideLoading();
}

// ---------------- Ø§Ù„ØªØ´ØºÙŠÙ„ ----------------
async function init() {
  showLoading();
  totalEpisodes = await getTotalEpisodes();
  const currentPage = getPageFromURL();
  await renderPage(currentPage);
  hideLoading();
}

// init + Ø§Ù„ØªØ­Ù‚Ù‚ ÙƒÙ„ 10 Ø¯Ù‚Ø§Ø¦Ù‚
init();
setInterval(() => {
  console.log("ğŸ” Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©...");
  checkForUpdates();
}, 10 * 60 * 1000);

</script>




</main>

<script>
    // Fetch and inject the navbar content
    fetch('navbar.html')
        .then(response => response.text())
        .then(data => document.getElementById('navbar-container').innerHTML = data)
        .catch(error => console.error("Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ†Ù‚Ù„:", error));
</script>
<div style="margin: 15px 0; text-align: center;">
  <script async="async" data-cfasync="false" src="//pl27400501.profitableratecpm.com/cccf85ebe49cd5752952d5b413cfb457/invoke.js"></script>
  <div id="container-cccf85ebe49cd5752952d5b413cfb457"></div>
</div>

</body>
</html>












