<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Ø£Ø­Ø¯Ø« Ø­Ù„Ù‚Ø§Øª</title>
    <link rel="stylesheet" href="CSS/style.css" />
    <script src="navbar.js" defer></script>
    <link rel="icon" href="https://abdo12249.github.io/1/navbar/favicon.ico" type="image/x-icon" />

    <!-- Firebase SDKs -->
<!-- Firebase SDK v9 (Ù…ØªÙˆØ§ÙÙ‚Ø© Ù…Ø¹ ÙƒÙˆØ¯Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ) -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-analytics-compat.js"></script>


    <style>
        /* Pagination styling for the navigation buttons */
        .pagination {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 8px;
            margin: 20px 0;
        }
        .pagination button {
            padding: 6px 12px;
            background-color: var(--primary-color, #ef4444);
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 6px;
            transition: background-color 0.3s ease; /* Smooth transition for hover effects */
        }
        .pagination button:hover {
            background-color: #dc2626; /* Slightly darker on hover */
        }
        .pagination button.active {
            background-color: #b91c1c; /* Active button color */
        }
        .pagination span {
            padding: 6px 12px;
            color: #888;
        }

        /* Loading overlay styles */
        .loading-overlay {
            position: fixed; /* Fixed position to cover the entire viewport */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black background */
            display: flex; /* Use flexbox for centering content */
            flex-direction: column; /* Stack items vertically */
            justify-content: center; /* Center vertically */
            align-items: center; /* Center horizontally */
            z-index: 1000; /* Ensure it's on top of other content */
            color: white; /* Text color */
            font-size: 1.2em; /* Larger font size for text */
        }

        /* Spinner animation */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3); /* Light border for the spinner */
            border-top: 4px solid #fff; /* White top border for animation */
            border-radius: 50%; /* Make it circular */
            width: 40px; /* Spinner width */
            height: 40px; /* Spinner height */
            animation: spin 1s linear infinite; /* Spin animation */
            margin-bottom: 15px; /* Space below the spinner */
        }

        /* Keyframes for the spin animation */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Anime card image loading transition */

        .anime-image img.loaded {
            opacity: 1; /* Fully visible when loaded */
        }
    </style>
</head>
<body>

<div id="navbar-container"></div>

<main>
    <div class="section-header">
        <h1>Ø£Ø­Ø¯Ø« Ø­Ù„Ù‚Ø§Øª</h1>
    </div>

<div style="max-width:100%;overflow:hidden;">
    <script type="text/javascript">
        atOptions = {
            'key' : 'fcb1605c77b3fd33d38ff238d2ffbd00',
            'format' : 'iframe',
            'height' : 90,
            'width' : 728,
            'params' : {}
        };
    </script>
    <script type="text/javascript" src="//www.highperformanceformat.com/fcb1605c77b3fd33d38ff238d2ffbd00/invoke.js"></script>
</div>

<style>
iframe {
    max-width: 100% !important;
    height: auto !important;
}
</style>

    
    <div class="anime-grid" id="animeGrid"></div>
    <div class="pagination" id="pagination"></div>

    <!-- Loading screen overlay -->
    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="spinner"></div>
        <span>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…ÙŠ...</span>
    </div>

<script>
  // ğŸ”§ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Firebase Ø§Ù„Ø®Ø§ØµØ© Ø¨Ùƒ
  const firebaseConfig = {
    apiKey: "AIzaSyAQpXUUOLyN2B6IWGb5Ru2Dl8NZPNimTEg",
    authDomain: "wep1-25124.firebaseapp.com",
    databaseURL: "https://wep1-25124-default-rtdb.firebaseio.com",
    projectId: "wep1-25124",
    storageBucket: "wep1-25124.appspot.com",
    messagingSenderId: "400763524699",
    appId: "1:400763524699:web:b3d5b77815de059ad9117e",
    measurementId: "G-ER2GCC7BK4"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  const maxItemsPerPage = 20;
  const EPISODES_PER_PART = 500;
  let allEpisodes = [];

  function showLoading() { document.getElementById("loadingOverlay").style.display = "flex"; }
  function hideLoading() { document.getElementById("loadingOverlay").style.display = "none"; }

  function getPageFromURL() {
    const params = new URLSearchParams(window.location.search);
    return parseInt(params.get("page")) || 1;
  }

  function updateURL(page) {
    const url = new URL(window.location.href);
    url.searchParams.set("page", page);
    window.history.pushState({}, "", url);
  }

  function renderPage(pageNumber) {
    updateURL(pageNumber);
    const animeGrid = document.getElementById("animeGrid");
    animeGrid.innerHTML = "";
    const startIndex = (pageNumber - 1) * maxItemsPerPage;
    const endIndex = startIndex + maxItemsPerPage;
    const episodesToShow = allEpisodes.slice(startIndex, endIndex);

    episodesToShow.forEach(ep => {
      const card = document.createElement("div");
      card.className = "anime-card";
      card.innerHTML = `
        <div class="anime-image"><img src="${ep.image}" alt="${ep.animeTitle}" loading="lazy"></div>
        <div class="anime-info">
          <h3>${ep.animeTitle}</h3>
          <div class="anime-meta">
            <span>${ep.title}</span>
            <a href="${ep.link}" class="watch-button">Ø´Ø§Ù‡Ø¯ Ø§Ù„Ø¢Ù†</a>
          </div>
        </div>`;
      animeGrid.appendChild(card);
    });

    document.querySelectorAll(".pagination button").forEach(b => b.classList.remove("active"));
    const activeBtn = document.querySelector(`.pagination button[data-page="${pageNumber}"]`);
    if (activeBtn) activeBtn.classList.add("active");
    window.scrollTo({ top: 0, behavior: "smooth" });
  }

  function setupPagination(totalItems, currentPage) {
    const pageCount = Math.ceil(totalItems / maxItemsPerPage);
    const pagination = document.getElementById("pagination");
    pagination.innerHTML = "";
    const maxVisible = 5;
    let start = Math.max(1, currentPage - Math.floor(maxVisible / 2));
    let end = Math.min(start + maxVisible - 1, pageCount);
    if (end - start < maxVisible - 1) start = Math.max(1, end - maxVisible + 1);

    if (currentPage > 1) {
      const prev = document.createElement("button");
      prev.textContent = "Ø§Ù„Ø³Ø§Ø¨Ù‚";
      prev.onclick = () => { renderPage(currentPage - 1); setupPagination(totalItems, currentPage - 1); };
      pagination.appendChild(prev);
    }

    for (let i = start; i <= end; i++) {
      const btn = document.createElement("button");
      btn.textContent = i;
      btn.setAttribute("data-page", i);
      if (i === currentPage) btn.classList.add("active");
      btn.onclick = () => { renderPage(i); setupPagination(totalItems, i); };
      pagination.appendChild(btn);
    }

    if (currentPage < pageCount) {
      const next = document.createElement("button");
      next.textContent = "Ø§Ù„ØªØ§Ù„ÙŠ";
      next.onclick = () => { renderPage(currentPage + 1); setupPagination(totalItems, currentPage + 1); };
      pagination.appendChild(next);
    }
  }

  async function fetchWithConcurrencyLimit(urls, limit) {
    const results = [];
    const queue = [...urls];
    async function worker() {
      while (queue.length > 0) {
        const url = queue.shift();
        if (!url) continue;
        try {
          const res = await fetch(url);
          const data = await res.json();
          results.push(data);
        } catch {
          results.push(null);
        }
      }
    }
    const workers = Array(limit).fill(null).map(() => worker());
    await Promise.all(workers);
    return results;
  }

  async function uploadEpisodesInParts(episodes) {
    const totalParts = Math.ceil(episodes.length / EPISODES_PER_PART);
    const uploadedParts = [];

    for (let i = 0; i < totalParts; i++) {
      const start = i * EPISODES_PER_PART;
      const end = start + EPISODES_PER_PART;
      const partEpisodes = episodes.slice(start, end);
      const partDocRef = db.collection("episodes").doc(`part${i + 1}`);

      const existing = await partDocRef.get();
      if (existing.exists && JSON.stringify(existing.data().episodes) === JSON.stringify(partEpisodes)) {
        console.log(`â­ï¸ Ø§Ù„Ø¬Ø²Ø¡ part${i + 1} Ù„Ù… ÙŠØªØºÙŠØ±ØŒ ØªÙ… ØªØ®Ø·ÙŠÙ‡.`);
        continue;
      }

      await partDocRef.set({ episodes: partEpisodes, updatedAt: Date.now() });
      console.log(`âœ… ØªÙ… Ø±ÙØ¹ part${i + 1} (${partEpisodes.length} Ø­Ù„Ù‚Ø©)`);

      uploadedParts.push(`part${i + 1}`);
    }

    if (uploadedParts.length > 0) {
      console.log(`ğŸ”¥ ØªÙ… Ø±ÙØ¹ ${uploadedParts.length} Ø£Ø¬Ø²Ø§Ø¡ Ø¬Ø¯ÙŠØ¯Ø© Ø¥Ù„Ù‰ Firestore!`);
    } else {
      console.log("âœ… Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©.");
    }
  }

  async function fetchAndUploadIfNeeded() {
    showLoading();
    try {
      const res = await fetch("Ø§Ù„Ø¬Ø¯ÙŠØ¯.json");
      const data = await res.json();
      const animeLinks = data.animes;
      const fetchedAnimeData = await fetchWithConcurrencyLimit(animeLinks, 5);

      const fetchedEpisodes = [];
      fetchedAnimeData.forEach(animeData => {
        if (!animeData) return;
        animeData.episodes.forEach(ep => {
          fetchedEpisodes.push({
            animeTitle: animeData.animeTitle,
            image: ep.image,
            link: ep.link,
            number: ep.number,
            title: ep.title,
            date: ep.date || new Date().toISOString()
          });
        });
      });

      fetchedEpisodes.sort((a, b) => new Date(b.date) - new Date(a.date));

      await uploadEpisodesInParts(fetchedEpisodes);
    } catch (e) {
      console.error("âŒ Ø®Ø·Ø£:", e);
    } finally {
      hideLoading();
    }
  }

  // ØªØ­Ù…ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ù…Ù† Firestore Ù„Ø¹Ø±Ø¶Ù‡Ø§
  // ØªØ­Ù…ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ù…Ù† Firestore Ø¨Ø³Ø±Ø¹Ø© (Ù…ØªÙˆØ§Ø²ÙŠ)
async function loadAllParts() {
  const snapshot = await db.collection("episodes").get();
  const promises = [];

  snapshot.forEach(doc => {
    if (doc.id.startsWith("part")) {
      promises.push(Promise.resolve(doc.data().episodes));
    }
  });

  const partsData = await Promise.all(promises);
  const all = partsData.flat();
  all.sort((a, b) => new Date(b.date) - new Date(a.date));
  return all;
}


  async function init() {
    showLoading();
    const parts = await db.collection("episodes").get();
    if (parts.empty) {
      console.log("âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø¹Ø¯ØŒ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ­Ù…ÙŠÙ„...");
      await fetchAndUploadIfNeeded();
    }

    allEpisodes = await loadAllParts();
    const currentPage = getPageFromURL();
    renderPage(currentPage);
    setupPagination(allEpisodes.length, currentPage);
    hideLoading();
  }

  init();
</script>

</main>

<script>
    // Fetch and inject the navbar content
    fetch('navbar.html')
        .then(response => response.text())
        .then(data => document.getElementById('navbar-container').innerHTML = data)
        .catch(error => console.error("Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ†Ù‚Ù„:", error));
</script>
<div style="margin: 15px 0; text-align: center;">
  <script async="async" data-cfasync="false" src="//pl27400501.profitableratecpm.com/cccf85ebe49cd5752952d5b413cfb457/invoke.js"></script>
  <div id="container-cccf85ebe49cd5752952d5b413cfb457"></div>
</div>

</body>
</html>






